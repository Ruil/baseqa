package edu.cmu.lti.oaqa.gerp.core;

import java.util.Collection;
import java.util.List;
import java.util.Map;

import org.apache.uima.UimaContext;
import org.apache.uima.analysis_engine.AnalysisEngine;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.analysis_engine.JCasIterator;
import org.apache.uima.cas.AbstractCas;
import org.apache.uima.cas.CAS;
import org.apache.uima.fit.component.JCasMultiplier_ImplBase;
import org.apache.uima.fit.descriptor.OperationalProperties;
import org.apache.uima.fit.util.JCasUtil;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.cas.TOP;
import org.apache.uima.jcas.tcas.Annotation;
import org.apache.uima.resource.ResourceInitializationException;
import org.apache.uima.util.CasCopier;
import org.oaqa.model.gerp.GerpMeta;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import edu.cmu.lti.oaqa.core.data.TopWrapper;
import edu.cmu.lti.oaqa.core.data.WrapperHelper;
import edu.cmu.lti.oaqa.core.data.WrapperIndexer;
import edu.cmu.lti.oaqa.ecd.BaseExperimentBuilder;
import edu.cmu.lti.oaqa.framework.types.ProcessingStep;
import edu.cmu.lti.oaqa.gerp.data.EvidenceWrapper;
import edu.cmu.lti.oaqa.gerp.data.GerpMetaWrapper;
import edu.cmu.lti.oaqa.gerp.data.Gerpable;
import edu.cmu.lti.oaqa.gerp.data.GerpableList;
import edu.cmu.lti.oaqa.gerp.data.PruningDecisionWrapper;
import edu.cmu.lti.oaqa.gerp.data.RankWrapper;

/**
 * Extended from {@link edu.cmu.lti.oaqa.ecd.phase.BasePhase}, which instead of using
 * <code>options</code> for integrating components, generators, evidencers, rankers and pruners
 * inherited from {@link AbstractGenerator}, {@link AbstractEvidencer}, {@link AbstractRanker}, or
 * {@link AbstractPruner} should be listed in separated fields in the descriptor. Moreover, the type
 * of the {@link TOP} or {@link Annotation} should be specified for the parameter <code>type</code>.
 * Other options, e.g. <code>name</code>, <code>option-timeout</code>,
 * <code>lazy-load-options</code> are preserved.
 * <p>
 * Each combination of TOPs generated by previous {@link GerpPhase}s (
 * {@link JCasMultiplier_ImplBase} implementations), claimed by
 * {@link AbstractGenerator#getRequiredInputTypes()} as input arguments, will be stored in different
 * {@link CAS}es and processed by the {@link #process(JCas)} separately, and further passed along
 * the pipeline within the analysis engine for evidencing, ranking and pruning. The number of
 * {@link CAS}es output from the {@link #next()} method of each GerpPhase instance is equal to the
 * number of <code>generator</code>s defined in the descriptor.
 * 
 * @author Zi Yang <ziy@cs.cmu.edu>
 * 
 */
@OperationalProperties(outputsNewCases = true)
public class GerpPhase<T extends TOP, W extends Gerpable & TopWrapper<T>> extends
        JCasMultiplier_ImplBase {

  /*
   * Field name constants copied from BasePhase
   */
  public static final String QA_INTERNAL_PHASEID = "__.qa.internal.phaseid.__";

  public static final String TIMEOUT_KEY = "option-timeout";

  public static final String LAZY_LOAD_KEY = "lazy-load-options";

  private Map<String, Object> confs;

  private String gerpableClassName;

  private int gerpableType;

  private GerpMetaWrapper gerpMeta;

  private AnalysisEngine generatorSubPhase, evidencerSubPhase, rankerSubPhase, prunerSubPhase;

  private JCas mergedJcas;

  private WrapperIndexer mergedCasIndexer;

  private GerpableList<T, W> gerpables;

  private ListMultimap<W, ProcessingStep> gerpable2steps;

  private int gerpableIdx;

  @Override
  public void initialize(UimaContext context) throws ResourceInitializationException {
    super.initialize(context);
    confs = GerpPhaseUtils.getConfigurationTuples(context, "persistence-provider", "name",
            QA_INTERNAL_PHASEID, TIMEOUT_KEY, LAZY_LOAD_KEY,
            BaseExperimentBuilder.EXPERIMENT_UUID_PROPERTY,
            BaseExperimentBuilder.STAGE_ID_PROPERTY, "generators", "evidencers", "rankers",
            "pruners");
    try {
      gerpableClassName = (String) context.getConfigParameterValue("type");
      Class<? extends TOP> topClass = Class.forName(gerpableClassName).asSubclass(TOP.class);
      gerpableType = (Integer) topClass.getDeclaredField("type").get(null);
    } catch (Exception e) {
      throw new ResourceInitializationException(e);
    }
    gerpMeta = new GerpMetaWrapper(gerpableClassName, GerpPhaseUtils.toClassNames((String) confs
            .get("generators")), GerpPhaseUtils.toClassNames((String) confs.get("evidencers")),
            GerpPhaseUtils.toClassNames((String) confs.get("rankers")),
            GerpPhaseUtils.toClassNames((String) confs.get("pruners")));
  }

  @Override
  public void process(JCas aJCas) throws AnalysisEngineProcessException {
    // initialize
    mergedCasIndexer = new WrapperIndexer();
    gerpables = new GerpableList<T, W>();
    gerpable2steps = ArrayListMultimap.create();
    gerpableIdx = 0;
    Map<String, Object> subPhaseConfs = GerpPhaseUtils
            .copyTuples(confs, "persistence-provider", QA_INTERNAL_PHASEID, TIMEOUT_KEY,
                    LAZY_LOAD_KEY, BaseExperimentBuilder.EXPERIMENT_UUID_PROPERTY,
                    BaseExperimentBuilder.STAGE_ID_PROPERTY);
    mergedJcas = aJCas;
    WrapperHelper.unwrap(new WrapperIndexer(), gerpMeta, mergedJcas).addToIndexes(mergedJcas);
    JCasIterator jcasIter;
    // create generation subphase
    subPhaseConfs.put("name", confs.get("name") + "|GENERATION");
    subPhaseConfs.put("options", confs.get("generators"));
    generatorSubPhase = GerpPhaseUtils.createBasePhase(subPhaseConfs);
    // execute generation subphase
    JCas inputJcas = copyJcas(mergedJcas);
    jcasIter = generatorSubPhase.processAndOutputNewCASes(inputJcas);
    // merge generated gerpables
    mergeGerpables(jcasIter);
    // create evidencing subphase
    subPhaseConfs.put("name", confs.get("name") + "|EVIDENCING");
    subPhaseConfs.put("options", confs.get("evidencers"));
    evidencerSubPhase = GerpPhaseUtils.createBasePhase(subPhaseConfs);
    // execute evidencing subphase
    inputJcas = copyJcas(mergedJcas);
    jcasIter = evidencerSubPhase.processAndOutputNewCASes(inputJcas);
    // merge evidences
    mergeEvidences(jcasIter);
    // create ranking subphase
    subPhaseConfs.put("name", confs.get("name") + "|RANKING");
    subPhaseConfs.put("options", confs.get("rankers"));
    rankerSubPhase = GerpPhaseUtils.createBasePhase(subPhaseConfs);
    // execute ranking subphase
    inputJcas = copyJcas(mergedJcas);
    jcasIter = rankerSubPhase.processAndOutputNewCASes(inputJcas);
    // merge ranks
    mergeRanks(jcasIter);
    // create pruning subphase
    subPhaseConfs.put("name", confs.get("name") + "|PRUNING");
    subPhaseConfs.put("options", confs.get("pruners"));
    prunerSubPhase = GerpPhaseUtils.createBasePhase(subPhaseConfs);
    // execute pruning subphase
    inputJcas = copyJcas(mergedJcas);
    jcasIter = prunerSubPhase.processAndOutputNewCASes(inputJcas);
    // merge pruning decisions
    mergePruningDecisions(jcasIter);
    // post processing
    ultimatePrune();
    GerpPhaseUtils.removeAllTopsFromIndexesAndIndexer(mergedJcas, mergedCasIndexer, GerpMeta.type);
  }

  private JCas copyJcas(JCas jcas) {
    JCas ret = getEmptyJCas();
    CasCopier.copyCas(jcas.getCas(), ret.getCas(), true);
    return ret;
  }

  private void mergeGerpables(JCasIterator jcasIter) throws AnalysisEngineProcessException {
    while (jcasIter.hasNext()) {
      JCas jcas = jcasIter.next();
      TOP top = Iterables.getOnlyElement(GerpPhaseUtils.getAllTops(jcas, gerpableType));
      @SuppressWarnings("unchecked")
      W gerpable = (W) WrapperHelper.wrap(new WrapperIndexer(), top);
      gerpable.setGerpMeta(gerpMeta);
      gerpables.add(gerpable);
      gerpable2steps.putAll(gerpable, copyAllProcessingSteps(jcas, mergedJcas));
      jcas.release();
    }
    for (W gerpable : gerpables.getGerpables()) {
      T top = WrapperHelper.unwrap(mergedCasIndexer, gerpable, mergedJcas);
      top.addToIndexes(mergedJcas);
    }
  }

  private void mergeEvidences(JCasIterator jcasIter) throws AnalysisEngineProcessException {
    Map<W, EvidenceWrapper<?, ?>> gerpable2evidences = Maps.newHashMap();
    while (jcasIter.hasNext()) {
      JCas jcas = jcasIter.next();
      for (TOP top : GerpPhaseUtils.getAllTops(jcas, gerpableType)) {
        @SuppressWarnings("unchecked")
        W gerpable = (W) WrapperHelper.wrap(new WrapperIndexer(), top);
        gerpable2evidences.put(gerpable, gerpable.getEvidences().get(0));
      }
      gerpables.addAllEvidences(gerpable2evidences);
      for (W gerpable : gerpable2steps.keySet()) {
        gerpable2steps.putAll(gerpable, copyAllProcessingSteps(jcas, mergedJcas));
      }
      jcas.release();
    }
    GerpPhaseUtils.removeAllTopsFromIndexesAndIndexer(mergedJcas, mergedCasIndexer, gerpableType);
    for (W gerpable : gerpables.getGerpables()) {
      T top = WrapperHelper.unwrap(mergedCasIndexer, gerpable, mergedJcas);
      top.addToIndexes(mergedJcas);
    }
  }

  private void mergeRanks(JCasIterator jcasIter) throws AnalysisEngineProcessException {
    Map<W, RankWrapper> gerpable2ranks = Maps.newHashMap();
    while (jcasIter.hasNext()) {
      JCas jcas = jcasIter.next();
      for (TOP top : GerpPhaseUtils.getAllTops(jcas, gerpableType)) {
        @SuppressWarnings("unchecked")
        W gerpable = (W) WrapperHelper.wrap(new WrapperIndexer(), top);
        gerpable2ranks.put(gerpable, gerpable.getRanks().get(0));
      }
      gerpables.addAllRanks(gerpable2ranks);
      for (W gerpable : gerpable2steps.keySet()) {
        gerpable2steps.putAll(gerpable, copyAllProcessingSteps(jcas, mergedJcas));
      }
      jcas.release();
    }
    GerpPhaseUtils.removeAllTopsFromIndexesAndIndexer(mergedJcas, mergedCasIndexer, gerpableType);
    for (W gerpable : gerpables.getGerpables()) {
      T top = WrapperHelper.unwrap(mergedCasIndexer, gerpable, mergedJcas);
      top.addToIndexes(mergedJcas);
    }
  }

  private void mergePruningDecisions(JCasIterator jcasIter) throws AnalysisEngineProcessException {
    Map<W, PruningDecisionWrapper> gerpable2pruningDecisions = Maps.newHashMap();
    while (jcasIter.hasNext()) {
      JCas jcas = jcasIter.next();
      for (TOP top : GerpPhaseUtils.getAllTops(jcas, gerpableType)) {
        @SuppressWarnings("unchecked")
        W gerpable = (W) WrapperHelper.wrap(new WrapperIndexer(), top);
        gerpable2pruningDecisions.put(gerpable, gerpable.getPruningDecisions().get(0));
      }
      gerpables.addAllPruningDecisions(gerpable2pruningDecisions);
      for (W gerpable : gerpable2steps.keySet()) {
        gerpable2steps.putAll(gerpable, copyAllProcessingSteps(jcas, mergedJcas));
      }
      jcas.release();
    }
    GerpPhaseUtils.removeAllTopsFromIndexesAndIndexer(mergedJcas, mergedCasIndexer, gerpableType);
  }

  private void ultimatePrune() {
    // TODO Auto-generated method stub

  }

  @Override
  public boolean hasNext() throws AnalysisEngineProcessException {
    if (gerpableIdx < gerpables.size()) {
      return true;
    } else {
      mergedJcas.release();
      return false;
    }
  }

  @Override
  public AbstractCas next() throws AnalysisEngineProcessException {
    JCas output = getEmptyJCas();
    W gerpable = gerpables.get(gerpableIdx++);
    CasCopier.copyCas(mergedJcas.getCas(), output.getCas(), true);
    copyAndIndexAllProcessingSteps(gerpable2steps.get(gerpable), output);
    T top = WrapperHelper.unwrap(new WrapperIndexer(), gerpable, output);
    top.addToIndexes(output);
    return output;
  }

  @Override
  public void collectionProcessComplete() throws AnalysisEngineProcessException {
    super.collectionProcessComplete();
    generatorSubPhase.collectionProcessComplete();
    evidencerSubPhase.collectionProcessComplete();
    rankerSubPhase.collectionProcessComplete();
    prunerSubPhase.collectionProcessComplete();
  }

  private static List<ProcessingStep> copyAllProcessingSteps(JCas srcJcas, JCas destJcas) {
    List<ProcessingStep> processingSteps = Lists.newArrayList();
    CasCopier copier = new CasCopier(srcJcas.getCas(), destJcas.getCas());
    for (ProcessingStep processingStep : JCasUtil.select(srcJcas, ProcessingStep.class)) {
      processingSteps.add((ProcessingStep) copier.copyFs(processingStep));
    }
    return processingSteps;
  }

  private static void copyAndIndexAllProcessingSteps(Collection<ProcessingStep> srcProcessingSteps,
          JCas destJcas) {
    for (ProcessingStep processingStep : srcProcessingSteps) {
      CasCopier copier = new CasCopier(processingStep.getCAS(), destJcas.getCas());
      destJcas.addFsToIndexes((ProcessingStep) copier.copyFs(processingStep));
    }
  }

}